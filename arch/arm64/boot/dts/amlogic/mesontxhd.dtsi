/*
 * arch/arm64/boot/dts/amlogic/mesontxhd.dtsi
 *
 * Copyright (C) 2017 Amlogic, Inc. All rights reserved.
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
 * more details.
 *
*/

#include <dt-bindings/clock/txlx.h>
#include <dt-bindings/gpio/txhd.h>
#include <dt-bindings/gpio/gpio.h>
#include <dt-bindings/reset/aml_txlx.h>
#include <dt-bindings/thermal/thermal.h>
#include <dt-bindings/interrupt-controller/arm-gic.h>
#include <dt-bindings/input/input.h>
#include <dt-bindings/input/meson_rc.h>
#include <dt-bindings/pwm/pwm.h>
#include <dt-bindings/pwm/meson.h>
#include "mesongxbb-gpu-mali450.dtsi"

/ {
	cpus:cpus {
		#address-cells = <2>;
		#size-cells = <0>;
		#cooling-cells = <2>; /* min followed by max */

		cpu0:cpu@0 {
			device_type = "cpu";
			compatible = "arm,cortex-a53","arm,armv8";
			reg = <0x0 0x0>;
			enable-method = "psci";
		};

		cpu1:cpu@1 {
			device_type = "cpu";
			compatible = "arm,cortex-a53","arm,armv8";
			reg = <0x0 0x1>;
			enable-method = "psci";
		};
	};

	timer {
		compatible = "arm,armv8-timer";
		interrupts = <GIC_PPI 13 0xff01>,
			     <GIC_PPI 14 0xff01>,
			     <GIC_PPI 11 0xff01>,
			     <GIC_PPI 10 0xff01>;
	};

	timer_bc {
		compatible = "arm, meson-bc-timer";
		reg=   <0x0 0xffd0f190 0x0 0x4 0x0 0xffd0f194 0x0 0x4>;
		timer_name = "Meson TimerF";
		clockevent-rating=<300>;
		clockevent-shift=<20>;
		clockevent-features=<0x23>;
		interrupts = <0 60 1>;
		bit_enable=<16>;
		bit_mode=<12>;
		bit_resolution=<0>;
	};

	arm_pmu {
		compatible = "arm,armv8-pmuv3";
		interrupts = <0 137 4>,
			     <0 138 4>,
			     <0 153 4>,
			     <0 154 4>;
	};

	meson_suspend:pm {
		compatible = "amlogic, pm";
		device_name = "aml_pm";
		/*gxbaby-suspend;*/
		status = "okay";
		reg = <0x0 0xff8000a8 0x0 0x4
		       0x0 0xff80023c 0x0 0x4>;
	};

	gic: interrupt-controller@2c001000 {
		compatible = "arm,cortex-a15-gic", "arm,cortex-a9-gic";
		#interrupt-cells = <3>;
		#address-cells = <0>;
		interrupt-controller;
		reg = <0x0 0xffc01000 0 0x1000>,
		      <0x0 0xffc02000 0 0x0100>;
		interrupts = <GIC_PPI 9 0xf04>;
	};

	aml_restart {
		compatible = "aml, restart";
		status = "okay";
		sys_reset = <0x84000009>;
		sys_poweroff = <0x84000008>;
	};

	psci {
		compatible = "arm,psci-1.0";
		method = "smc";
		cpu_suspend = <0xC4000001>;
		cpu_off = <0x84000002>;
		cpu_on = <0xC4000003>;
		migrate = <0xC4000005>;
	};

	secmon {
		compatible = "amlogic, secmon";
		memory-region = <&secmon_reserved>;
		in_base_func = <0x82000020>;
		out_base_func = <0x82000021>;
	};

	securitykey {
		compatible = "aml, securitykey";
		status = "okay";
		storage_query = <0x82000060>;
		storage_read = <0x82000061>;
		storage_write = <0x82000062>;
		storage_tell = <0x82000063>;
		storage_verify = <0x82000064>;
		storage_status = <0x82000065>;
		storage_list = <0x82000067>;
		storage_remove = <0x82000068>;
		storage_in_func = <0x82000023>;
		storage_out_func = <0x82000024>;
		storage_block_func = <0x82000025>;
		storage_size_func = <0x82000027>;
		storage_set_enctype = <0x8200006A>;
		storage_get_enctype = <0x8200006B>;
		storage_version = <0x8200006C>;
	};

	cpu_iomap {
		compatible = "amlogic, iomap";
		#address-cells=<2>;
		#size-cells=<2>;
		ranges;
		io_cbus_base {
			reg = <0x0 0xffd00000 0x0 0x100000>;
		};
		io_apb_base {
			reg = <0x0 0xffe00000 0x0 0x100000>;
		};
		io_aobus_base {
			reg = <0x0 0xff800000 0x0 0x100000>;
		};
		io_vapb_base {
			reg = <0x0 0xff900000 0x0 0x050000>;
		};
	};

	cpufreq-meson {
		compatible = "amlogic, cpufreq-scpi";
		status = "okay";
		clocks = <&scpi_dvfs 0>;
		clock-names = "cpu_clk";
        };

	pwm:meson-pwm {
		compatible = "amlogic, meson-pwm";
		status = "okay";
		#pwm-cells = <2>;
		pwm-outputs = <PWM_A>,<PWM_B>,<PWM_C>,<PWM_D>,
				  	<PWM_E>,<PWM_F>,<PWM_AO_A>,<PWM_AO_B>,
				  	<PWM_AO_C>,<PWM_AO_D>,<PWM_A2>,<PWM_B2>,
				  	<PWM_C2>,<PWM_D2>,<PWM_E2>,<PWM_F2>,<PWM_AO_A2>,
				  	<PWM_AO_B2>,<PWM_AO_C2>,<PWM_AO_D2>;
		reg = <0x0 0xffd1b000  0x0 0x20>,
		      <0x0 0xffd1a000  0x0 0x20>,
		      <0x0 0xffd19000  0x0 0x20>,
		      <0x0 0xff807000  0x0 0x20>,
		      <0x0 0xff802000  0x0 0x20>;
		clocks = <&clock CLK_XTAL>,
			 <&clock CLK_VID_PLL>,
			 <&clock CLK_FPLL_DIV4>,
			 <&clock CLK_FPLL_DIV3>;
		clock-names = "xtal",
			      "vid_pll_clk",
			      "fclk_div4",
			      "fclk_div3";
		clock-select = <XTAL_CLK>,<XTAL_CLK>,<XTAL_CLK>,<XTAL_CLK>,
		               <XTAL_CLK>,<XTAL_CLK>,<XTAL_CLK>,<XTAL_CLK>,
		               <XTAL_CLK>,<XTAL_CLK>;
	                   /*all channels use the default clock source XTAL_CLK*/
	                   /*and you can shoose it in file dt-bindings/pwm/meson.h*/
	};

	amlogic-watchdog {
		compatible = "amlogic, gx-wdt";
		status = "disable";
		default_timeout=<10>;
		reset_watchdog_method=<1>;//0:sysfs,1:kernel
		reset_watchdog_time=<2>;
		shutdown_timeout=<10>;
		firmware_timeout=<6>;
		suspend_timeout=<6>;
		reg = <0x0 0xffd0f0d0 0x0 0x10>;
		clocks = <&clock CLK_XTAL>;
	};

	amlogic-jtag {
		compatible = "amlogic, jtag";
		status = "okay";
	};

	clock: meson_clock {
		compatible = "amlogic, txhd-clock";
		reg = <0x0 0xff63c000 0x0 0x2000>,   /* HIU BUS */
		      <0x0 0xff800000 0x0 0x1000>;   /* AOBUS */
		#clock-cells = <1>;
		#reset-cells = <1>;
		sys_max = <1536000000>;
	};

	cpu_info {
		compatible = "amlogic, cpuinfo";
		status = "okay";
		cpuinfo_cmd = <0x82000044>;
	};

	vpu {
		compatible = "amlogic, vpu";
		dev_name = "vpu";
		status = "okay";
		clocks = <&clock CLK_VAPB_0>,
			<&clock CLK_VPU0>,
			<&clock CLK_VPU1>,
			<&clock CLK_VPU>;
		clock-names = "vapb_clk0","vpu_clk0","vpu_clk1","vpu_clk";
		clk_level = <5>;
		/**	0: 100.0M    1: 166.7M    2: 200.0M
			3: 250.0M    4: 333.3M    5: 400.0M
		 */
	};

	cpu_version {
		reg=<0x0 0xff800220 0x0 0x4>;
	};

	meson_clk_msr {
		compatible = "amlogic, txl_measure";
		reg = <0x0 0xffd18004 0x0 0x4
		       0x0 0xffd1800c 0x0 0x4>;
	};

	i2c_ao: i2c@ff805000{ /*I2C-AO*/
		compatible = "amlogic, meson-i2c";
		dev_name = "i2c-AO";
		status = "disabled";
		reg = <0x0 0xff805000 0x0 0x1d>;
		device_id = <0>;
		pinctrl-names="default";
		pinctrl-0=<&i2c_ao_gpioao_4_5_pins>;
		#address-cells = <1>;
		#size-cells = <0>;
		use_pio = <0>;
		master_i2c_speed = <300000>;
		clocks = <&clock CLK_81>;
		clock-names = "clk_i2c";
		resets = <&clock GCLK_IDX_I2C>;
	};
	i2c_a: i2c@ffd1f000 { /*I2C-A*/
		compatible = "amlogic, meson-i2c";
		dev_name = "i2c-A";
		status = "disabled";
		reg = <0x0 0xffd1f000 0x0 0x20>;
		device_id = <1>;
		pinctrl-names="default";
		pinctrl-0=<&i2c_a_gpiodv_pins>;/* change it in dts*/
		#address-cells = <1>;
		#size-cells = <0>;
		use_pio = <0>;
		master_i2c_speed = <300000>;
		clocks = <&clock CLK_81>;
		clock-names = "clk_i2c";
		resets = <&clock GCLK_IDX_I2C>;
	};

	i2c_b: i2c@ffd1e000 { /*I2C-B*/
		compatible = "amlogic, meson-i2c";
		dev_name = "i2c-B";
		status = "disabled";
		reg = <0x0 0xffd1e000 0x0 0x20>;
		device_id = <2>;
		pinctrl-names="default";
		pinctrl-0=<&i2c_b_gpiodv_pins>;
		#address-cells = <1>;
		#size-cells = <0>;
		use_pio = <0>;
		master_i2c_speed = <300000>;
		clocks = <&clock CLK_81>;
		clock-names = "clk_i2c";
		resets = <&clock GCLK_IDX_I2C>;
	};

	i2c_c: i2c@ffd1d000 { /*I2C-C*/
		compatible = "amlogic, meson-i2c";
		dev_name = "i2c-C";
		status = "disabled";
		reg = <0x0 0xffd1d000 0x0 0x20>;
		device_id = <3>;
		pinctrl-names="default";
		pinctrl-0=<&i2c_c_gpioc_pins>;
		#address-cells = <1>;
		#size-cells = <0>;
		use_pio = <0>;
		master_i2c_speed = <300000>;
		clocks = <&clock CLK_81>;
		clock-names = "clk_i2c";
		resets = <&clock GCLK_IDX_I2C>;
	};

	i2c_d: i2c@ffd1c000 { /*I2C-D*/
		compatible = "amlogic, meson-i2c";
		dev_name = "i2c-D";
		status = "disabled";
		reg = <0x0 0xffd1c000 0x0 0x20>;
		device_id = <4>;
		pinctrl-names="default";
		pinctrl-0=<&i2c_d_gpioh_pins>;
		#address-cells = <1>;
		#size-cells = <0>;
		use_pio = <0>;
		master_i2c_speed = <300000>;
		clocks = <&clock CLK_81>;
		clock-names = "clk_i2c";
		resets = <&clock GCLK_IDX_I2C>;
	};

	pinctrl_aobus: pinctrl@ff800014{
		compatible = "amlogic,meson-txhd-aobus-pinctrl";
		status = "okay";
		#address-cells = <2>;
		#size-cells = <2>;
		ranges;

		gpio_ao: ao-bank@ff800014{
			reg = <0x0 0xff800014 0x0 0x8>,
				  <0x0 0xff80002c 0x0 0x4>,
				  <0x0 0xff800024 0x0 0x8>,
				  <0x0 0xff800084 0x0 0x4>;
			interrupts = <0 200 1>,
				<0 201 1>;
			reg-names = "mux", "pull", "gpio", "irq";
			gpio-controller;
			#gpio-cells = <2>;
			interrupt-controller;
			#interrupt-cells = <2>;
		};
	};

	pinctrl_periphs: pinctrl@ff634480{
		compatible = "amlogic,meson-txhd-periphs-pinctrl";
		status = "okay";
		#address-cells = <2>;
		#size-cells = <2>;
		ranges;

		gpio: banks@ff634480{
			reg = <0x0 0xff634480 0x0 0x40>,
				  <0x0 0xff6344e8 0x0 0x10>,
				  <0x0 0xff634520 0x0 0x10>,
				  <0x0 0xff634430 0x0 0x30>,
				  <0x0 0xffd0f080 0x0 0x10>;
			interrupts = <0 64 1>,
				<0 65 1>,
				<0 66 1>,
				<0 67 1>,
				<0 68 1>,
				<0 69 1>,
				<0 70 1>,
				<0 71 1>;
			reg-names = "mux",
				"pull",
				"pull-enable",
				"gpio",
				"irq";
			gpio-controller;
			#gpio-cells = <2>;
			interrupt-controller;
			#interrupt-cells = <2>;
		};
	};

	efuse: efuse {
		compatible = "amlogic, efuse";
		read_cmd = <0x82000030>;
		write_cmd = <0x82000031>;
		get_max_cmd = <0x82000033>;
		key = <&efusekey>;
		resets = <&clock GCLK_IDX_EFUSE>;
		reset-names = "efuse_clk";
		status = "disabled";
	};

	efusekey:efusekey {
		keynum = <4>;
		key0 = <&key_0>;
		key1 = <&key_1>;
		key2 = <&key_2>;
		key3 = <&key_3>;
		key_0:key_0{
			keyname = "mac";
			offset = <0>;
			size = <6>;
		};
		key_1:key_1{
			keyname = "mac_bt";
			offset = <6>;
			size = <6>;
		};
		key_2:key_2{
			keyname = "mac_wifi";
			offset = <12>;
			size = <6>;
		};
		key_3:key_3{
			keyname = "usid";
			offset = <18>;
			size = <16>;
		};
	};

	mailbox: mhu@c883c400 {
		compatible = "amlogic, meson_mhu";
		reg = <0x0 0xff63c400 0x0 0x4c>,   /* MHU registers */
		      <0x0 0xfffd3000 0x0 0x800>;   /* Payload area */
		interrupts = <0 209 IRQ_TYPE_EDGE_RISING>,   /* low priority interrupt */
			     <0 210 IRQ_TYPE_EDGE_RISING>;   /* high priority interrupt */
		#mbox-cells = <1>;
		mbox-names = "cpu_to_scp_low", "cpu_to_scp_high";
		mboxes = <&mailbox 0 &mailbox 1>;
	};

	scpi_clocks {
		compatible = "arm,scpi-clks";
		status = "okay";
		scpi_dvfs: scpi_clocks@0 {
			compatible = "arm,scpi-clk-indexed";
			#clock-cells = <1>;
			clock-indices = <0>;
			clock-output-names = "vcpu";
		};

	};

	remote:rc@0xff808040 {
		compatible = "amlogic, aml_remote";
		dev_name = "meson-remote";
		reg = <0x0 0xff808040 0x00 0x44>,
			<0x0 0xff808000 0x00 0x20>;
		status = "okay";
		protocol = <REMOTE_TYPE_NEC>;
		interrupts = <0 196 1>;
		pinctrl-names = "default";
		pinctrl-0 = <&remote_pins>;
		map = <&custom_maps>;
		max_frame_time = <200>; /*set software decoder max frame time*/
	};

	custom_maps:custom_maps {
		mapnum = <2>;
		map0 = <&map_0>;
		map1 = <&map_1>;
		map_0: map_0{
			mapname = "amlogic-remote-1";
			customcode = <0xfb04>;
			release_delay = <80>;
			size  = <44>;   /*keymap size*/
			keymap = <REMOTE_KEY(0x01, KEY_1)
				REMOTE_KEY(0x02, KEY_2)
				REMOTE_KEY(0x03, KEY_3)
				REMOTE_KEY(0x04, KEY_4)
				REMOTE_KEY(0x05, KEY_5)
				REMOTE_KEY(0x06, KEY_6)
				REMOTE_KEY(0x07, KEY_7)
				REMOTE_KEY(0x08, KEY_8)
				REMOTE_KEY(0x09, KEY_9)
				REMOTE_KEY(0x0a, KEY_0)
				REMOTE_KEY(0x1F, KEY_FN_F1)
				REMOTE_KEY(0x15, KEY_MENU)
				REMOTE_KEY(0x16, KEY_TAB)
				REMOTE_KEY(0x0c, KEY_CHANNELUP)
				REMOTE_KEY(0x0d, KEY_CHANNELDOWN)
				REMOTE_KEY(0x0e, KEY_VOLUMEUP)
				REMOTE_KEY(0x0f, KEY_VOLUMEDOWN)
				REMOTE_KEY(0x11, KEY_HOME)
				REMOTE_KEY(0x1c, KEY_RIGHT)
				REMOTE_KEY(0x1b, KEY_LEFT)
				REMOTE_KEY(0x19, KEY_UP)
				REMOTE_KEY(0x1a, KEY_DOWN)
				REMOTE_KEY(0x1d, KEY_ENTER)
				REMOTE_KEY(0x17, KEY_MUTE)
				REMOTE_KEY(0x49, KEY_FINANCE)
				REMOTE_KEY(0x43, KEY_BACK)
				REMOTE_KEY(0x12, KEY_FN_F4)
				REMOTE_KEY(0x14, KEY_FN_F5)
				REMOTE_KEY(0x18, KEY_FN_F6)
				REMOTE_KEY(0x59, KEY_INFO)
				REMOTE_KEY(0x5a, KEY_STOPCD)
				REMOTE_KEY(0x10, KEY_POWER)
				REMOTE_KEY(0x42, KEY_PREVIOUSSONG)
				REMOTE_KEY(0x44, KEY_NEXTSONG)
				REMOTE_KEY(0x1e, KEY_REWIND)
				REMOTE_KEY(0x4b, KEY_FASTFORWARD)
				REMOTE_KEY(0x58, KEY_PLAYPAUSE)
				REMOTE_KEY(0x46, KEY_PROPS)
				REMOTE_KEY(0x40, KEY_UNDO)
				REMOTE_KEY(0x38, KEY_SCROLLLOCK)
				REMOTE_KEY(0x57, KEY_FN)
				REMOTE_KEY(0x5b, KEY_FN_ESC)
				REMOTE_KEY(0x13, 195)
				REMOTE_KEY(0x54, KEY_RED)
				REMOTE_KEY(0x4c, KEY_GREEN)
				REMOTE_KEY(0x4e, KEY_YELLOW)
				REMOTE_KEY(0x55, KEY_BLUE)
				REMOTE_KEY(0x53, KEY_BLUETOOTH)
				REMOTE_KEY(0x52, KEY_WLAN)
				REMOTE_KEY(0x39, KEY_CAMERA)
				REMOTE_KEY(0x41, KEY_SOUND)
				REMOTE_KEY(0x0b, KEY_QUESTION)
				REMOTE_KEY(0x00, KEY_CHAT)
				REMOTE_KEY(0x13, KEY_SEARCH)>;
		};
		map_1: map_1{
			mapname = "amlogic-remote-2";
			customcode = <0xfe01>;
			release_delay = <80>;
			size  = <53>;
			keymap = <REMOTE_KEY(0x01, KEY_1)
				REMOTE_KEY(0x02, KEY_2)
				REMOTE_KEY(0x03, KEY_3)
				REMOTE_KEY(0x04, KEY_4)
				REMOTE_KEY(0x05, KEY_5)
				REMOTE_KEY(0x06, KEY_6)
				REMOTE_KEY(0x07, KEY_7)
				REMOTE_KEY(0x08, KEY_8)
				REMOTE_KEY(0x09, KEY_9)
				REMOTE_KEY(0x0a, KEY_0)
				REMOTE_KEY(0x1F, KEY_FN_F1)
				REMOTE_KEY(0x15, KEY_MENU)
				REMOTE_KEY(0x16, KEY_TAB)
				REMOTE_KEY(0x0c, KEY_CHANNELUP)
				REMOTE_KEY(0x0d, KEY_CHANNELDOWN)
				REMOTE_KEY(0x0e, KEY_VOLUMEUP)
				REMOTE_KEY(0x0f, KEY_VOLUMEDOWN)
				REMOTE_KEY(0x11, KEY_HOME)
				REMOTE_KEY(0x1c, KEY_RIGHT)
				REMOTE_KEY(0x1b, KEY_LEFT)
				REMOTE_KEY(0x19, KEY_UP)
				REMOTE_KEY(0x1a, KEY_DOWN)
				REMOTE_KEY(0x1d, KEY_ENTER)
				REMOTE_KEY(0x17, KEY_MUTE)
				REMOTE_KEY(0x49, KEY_FINANCE)
				REMOTE_KEY(0x43, KEY_BACK)
				REMOTE_KEY(0x12, KEY_FN_F4)
				REMOTE_KEY(0x14, KEY_FN_F5)
				REMOTE_KEY(0x18, KEY_FN_F6)
				REMOTE_KEY(0x59, KEY_INFO)
				REMOTE_KEY(0x5a, KEY_STOPCD)
				REMOTE_KEY(0x10, KEY_POWER)
				REMOTE_KEY(0x42, KEY_PREVIOUSSONG)
				REMOTE_KEY(0x44, KEY_NEXTSONG)
				REMOTE_KEY(0x1e, KEY_REWIND)
				REMOTE_KEY(0x4b, KEY_FASTFORWARD)
				REMOTE_KEY(0x58, KEY_PLAYPAUSE)
				REMOTE_KEY(0x46, KEY_PROPS)
				REMOTE_KEY(0x40, KEY_UNDO)
				REMOTE_KEY(0x38, KEY_SCROLLLOCK)
				REMOTE_KEY(0x57, KEY_FN)
				REMOTE_KEY(0x5b, KEY_FN_ESC)
				REMOTE_KEY(0x54, KEY_RED)
				REMOTE_KEY(0x4c, KEY_GREEN)
				REMOTE_KEY(0x4e, KEY_YELLOW)
				REMOTE_KEY(0x55, KEY_BLUE)
				REMOTE_KEY(0x53, KEY_BLUETOOTH)
				REMOTE_KEY(0x52, KEY_WLAN)
				REMOTE_KEY(0x39, KEY_CAMERA)
				REMOTE_KEY(0x41, KEY_SOUND)
				REMOTE_KEY(0x0b, KEY_QUESTION)
				REMOTE_KEY(0x00, KEY_CHAT)
				REMOTE_KEY(0x13, KEY_SEARCH)>;
		};
 	};

	rng {
		compatible = "amlogic,meson-rng";
		reg = <0x0 0xff634500 0x0 0x4>;
	};

	audio_data:audio_data {
		compatible = "amlogic, audio_data";
		query_licence_cmd = <0x82000050>;
		status = "disabled";
	};

	saradc: saradc {
		compatible = "amlogic, saradc";
		status = "okay";
		interrupts = <0 9 1>;
		interrupt-names = "saradc_int";
		clocks = <&clock CLK_XTAL>;
		clock-names = "saradc_clk";
		reg = <0x0 0xff809000 0x0 0x30
			0x0 0xff800090 0x0 0x04>;
	};

	defendkey: defendkey {
		compatible = "amlogic, defendkey";
		reg = <0x0 0xff634500 0x0 0x4>; /*RAND64_ADDR0*/
		mem_size = <0x0 0x100000>;
		status = "disabled";
	};

	spicc_a:spicc_a {
		compatible = "amlogic, spicc";
		status = "disabled";
		reg = <0x0 0xffd13000 0x0 0x3c>;
		resets = <&clock GCLK_IDX_SPICC_0>;
		clocks = <&clock CLK_SPICC>,
							<&clock CLK_FPLL_DIV4>;
		clock-names = "spicc_clk", "parent";
		interrupts = <0 81 1>;
		device_id = <0>;
		enhance = <1>;
		pinctrl-names= "default";
		pinctrl-0=<&spicc_a_pins_dv>;
		dma_tx_threshold = <3>;
		dma_rx_threshold = <3>;
		dma_num_per_read_burst = <3>;
		dma_num_per_write_burst = <3>;
		ssctl = <0>;
	};

	aml_aes {
		 compatible = "amlogic,aes_dma";
		 dev_name = "aml_aes_dma";
		 interrupts = <0 188 1
			 0 189 1>;
		 reg = <0x0 0xff63e000 0x0 0x28>;
	 };
	 aml_tdes {
		 compatible = "amlogic,des_dma,tdes_dma";
		 dev_name = "aml_tdes_dma";
		 interrupts = <0 188 1
			 0 189 1>;
		 reg = <0x0 0xff63e000 0x0 0x28>;
	 };

	 aml_sha {
		 compatible = "amlogic,sha_dma";
		 dev_name = "aml_sha_dma";
		 interrupts = <0 188 1
			 0 189 1>;
		 reg = <0x0 0xff63e000 0x0 0x28>;
	 };

	ion_dev {
		compatible = "amlogic, ion_dev";
		status = "okay";
		memory-region = <&ion_reserved>;
	};

};/* end of / */

&gpu{
	reg = <0 0xFFE40000 0 0x40000>, /*mali APB bus base address*/
		<0 0xFFD04440 0 0x01000>, /*reset register*/
		<0 0xFF800000 0 0x01000>, /*aobus for gpu pmu domain*/
		<0 0xFF63c000 0 0x01000>, /*hiubus for gpu clk cntl*/
		<0 0xFFD04440 0 0x01000>; /*reset register*/
	tbl = <&clk125_cfg &clk285_cfg &clk400_cfg &clk500_cfg &clk666_cfg &clk750_cfg>;

	interrupts = <0 160 4>, <0 161 4>, <0 162 4>, <0 163 4>,
		<0 164 4>, <0 165 4>, <0 166 4>, <0 167 4>;
	interrupt-names = "IRQGP", "IRQGPMMU", "IRQPP", "IRQPMU",
		"IRQPP0", "IRQPPMMU0", "IRQPP1", "IRQPPMMU1";
	pmu_domain_config = <0x1 0x2 0x4 0x0 0x0 0x0 0x0 0x0 0x0 0x1 0x2 0x0>;
	num_of_pp = <2> ;
	sc_mpp = <2>;/* number of pp used most of time.*/
};

&pinctrl_aobus {
	remote_pins: remote_pin {
		mux {
			pins = "GPIOAO_6";
			function = "ir_in";
			bias-disable;
		};
	};

	i2c_ao_gpioao_4_5_pins: i2c_a_gpioao_4_5 {
		mux {
			pins = "GPIOAO_4","GPIOAO_5";
			function = "i2c_ao";
			bias-pull-up;
		};
	};

	i2c_ao_gpioao_10_11_pins: i2c_a_gpioao_10_11 {
		mux {
			pins = "GPIOAO_10","GPIOAO_11";
			function = "i2c_ao";
			bias-pull-up;
		};
	};

        ao_uart_pins:ao_uart {
		mux {
			pins = "GPIOAO_0",
				"GPIOAO_1";
			function = "uart_ao_a";
		};
	};

	ao_b_uart_pins:ao_b_uart {
		mux {
			pins = "GPIOAO_10",
				"GPIOAO_11";
			function = "uart_ao_b";
		};
	};

	aocec_pins:aocec_pins {
                mux {
                         pins = "GPIOAO_7";
                         function = "cec_ao";
                };
        };

        aocecb_pins: aocecb_pins {
                mux {
                          pins = "GPIOAO_7";
                          function = "cec_ao_b";
                };
        };
}; /* end of pinctrl_aobus */

&pinctrl_periphs {
	i2c_a_gpiodv_pins: i2c_a_gpiodv {
		mux {
			pins = "GPIODV_4","GPIODV_5";
			function = "i2c_a";
			bias-pull-up;
		};
	};

	i2c_a_gpioz_pins: i2c_a_gpioz {
		mux {
			pins = "GPIOZ_6","GPIOZ_7";
			function = "i2c_a";
			bias-pull-up;
		};
	};

	i2c_a_gpioh_pins: i2c_a_gpioz {
		mux {
			pins = "GPIOH_4","GPIOH_5";
			function = "i2c_a";
			bias-pull-up;
		};
	};

	i2c_b_gpiodv_pins: i2c_b_gpiodv {
		mux {
			pins = "GPIODV_0","GPIODV_1";
			function = "i2c_b";
			bias-pull-up;
		};
	};

	i2c_b_gpioz_pins: i2c_b_gpioz {
		mux {
			pins = "GPIOZ_0","GPIOZ_1";
			function = "i2c_b";
		};
	};

	i2c_c_gpioc_pins: i2c_c_gpioc {
		mux {
			pins = "GPIOC_2","GPIOC_3";
			function = "i2c_c";
		};
	};

	i2c_c_gpioh_pins: i2c_c_gpioh {
		mux {
			pins = "GPIOH_8","GPIOH_9";
			function = "i2c_c";
		};
	};

	i2c_d_gpioh_pins: i2c_d_gpioh {
		mux {
			pins = "GPIOH_0","GPIOH_1";
			function = "i2c_d";
		};
	};

	spicc_a_pins_dv: spicc_a_dv {
		mux {
			pins = "GPIODV_6", "GPIODV_7", "GPIODV_8", "GPIODV_9";
			function = "spi_a";
		};
	};

	sd_clk_cmd_pins: sd_clk_cmd_pins {
		mux {
			pins = "GPIOC_4", "GPIOC_5";
			function = "sdio";
			input-enable;
			bias-pull-up;
		};
	};

	sd_all_pins: sd_all_pins {
		mux {
			pins = "GPIOC_0", "GPIOC_1", "GPIOC_2", "GPIOC_3", "GPIOC_4", "GPIOC_5";
			function = "sdio";
			input-enable;
			bias-pull-up;
		};
	};

	emmc_clk_cmd_pins:emmc_clk_cmd_pins {
		mux {
			pins = "BOOT_8",
				"BOOT_10";
			function = "emmc";
			input-enable;
			bias-pull-up;
		};
	};


	emmc_conf_pull_up:emmc_conf_pull_up {
		mux {
			pins = "BOOT_0","BOOT_1","BOOT_2",
				"BOOT_3","BOOT_4","BOOT_5","BOOT_6",
				"BOOT_7","BOOT_8","BOOT_10";
			function = "emmc";
			input-enable;
			bias-pull-up;
		};
	};

	emmc_conf_pull_done:emmc_conf_pull_done {
		mux {
			pins = "BOOT_11";
			function = "emmc";
			input-enable;
			bias-pull-down;
		};
	};
        a_uart_pins:a_uart {
		mux {
			pins = "GPIOC_7",
				"GPIOC_8",
				"GPIOC_9",
				"GPIOC_10";
			function = "uart_a";
		};
	};

	b_uart_pins:b_uart {
		mux {
			pins = "GPIOZ_6",
				"GPIOZ_7";
			function = "uart_b";
		};
	};

	c_uart_pins:c_uart {
		mux {
			pins = "GPIOH_14",
				"GPIOH_15";
			function = "uart_c";
		};
	};

	atvdemod_agc: atvdemod_agc {
		mux {
			pins="GPIODV_2";
			function = "atv";
		};
	};
}; /* end of pinctrl_periphs */
